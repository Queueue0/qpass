package crypto

import (
	"crypto/ecdh"
	"crypto/rand"
	"encoding/base64"
	"fmt"
	"net"
	"time"
)

const pubKeySize = 32

type secureConn struct {
	c net.Conn
	ss []byte // Shared Secret, generated by dh
}

/*
 This is currently just an ECDH key exchange
 TODO:
	Server long-term keys
	Server Signature
	Server MAC
*/
func NewClientConn(c net.Conn) (*secureConn, error) {
	privkey, err := ecdh.X25519().GenerateKey(rand.Reader)
	if err != nil {
		return nil, err
	}

	pubkey := privkey.PublicKey()
	_, err = c.Write(pubkey.Bytes())
	if err != nil {
		return nil, err
	}

	b := make([]byte, pubKeySize)
	_, err = c.Read(b)
	if err != nil {
		return nil, err
	}

	remoteKey, err := ecdh.X25519().NewPublicKey(b)
	if err != nil {
		return nil, err
	}

	ss, err := privkey.ECDH(remoteKey)

	encStr := base64.RawStdEncoding.EncodeToString(ss)
	fmt.Println(encStr)

	return &secureConn{c, ss}, nil
}

func NewServerConn(c net.Conn) (*secureConn, error) {
	b := make([]byte, pubKeySize)
	_, err := c.Read(b)
	if err != nil {
		return nil, err
	}

	remoteKey, err := ecdh.X25519().NewPublicKey(b)
	if err != nil {
		return nil, err
	}

	privkey, err := ecdh.X25519().GenerateKey(rand.Reader)
	if err != nil {
		return nil, err
	}

	ss, err := privkey.ECDH(remoteKey)
	if err != nil {
		return nil, err
	}

	pubkey := privkey.PublicKey()
	_, err = c.Write(pubkey.Bytes())
	if err != nil {
		return nil, err
	}

	encStr := base64.RawStdEncoding.EncodeToString(ss)
	fmt.Println(encStr)

	return &secureConn{c, ss}, nil
}

// TODO: Decrypt received data
func (s *secureConn) Read(b []byte) (int, error) {
	return s.c.Read(b)
}

// TODO: Encrypt sent data
func (s *secureConn) Write(b []byte) (int, error) {
	return s.c.Write(b)
}

func (s *secureConn) Close() error {
	return s.c.Close()
}

func (s *secureConn) LocalAddr() net.Addr {
	return s.c.LocalAddr()
}

func (s *secureConn) RemoteAddr() net.Addr {
	return s.c.RemoteAddr()
}

func (s *secureConn) SetDeadline(t time.Time) error {
	return s.c.SetDeadline(t)
}

func (s *secureConn) SetReadDeadline(t time.Time) error {
	return s.c.SetReadDeadline(t)
}

func (s *secureConn) SetWriteDeadline(t time.Time) error {
	return s.c.SetWriteDeadline(t)
}
